# -*- coding: utf-8 -*-
"""Estimasi Berat Ikan.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1OoAdC1l2zMFiP7NXiEUX20lmyjWk71la
"""

import numpy as np # linear algebra
import pandas as pd # data processing, CSV file I/O (e.g. pd.read_csv)
import seaborn as sns
import matplotlib.pyplot as plt
import statsmodels.api as sm
import statsmodels.formula.api as smf
from sklearn.linear_model import LinearRegression
from sklearn.metrics import mean_squared_error, r2_score

from google.colab import files
data = files.upload()

data = pd.read_csv('Fish.csv')
df = data.copy()
df.sample(10)

# Ganti nama kolom
df.rename(columns={'Length1': 'LengthVer', 'Length2': 'LengthDia', 'Length3': 'LengthCro'}, inplace=True)

# Hapus kolom 'category'
df.drop(columns=['Category'], inplace=True)

# Tampilkan lima baris pertama dari DataFrame setelah perubahan
df.head()
#Species: Nama spesies ikan
#Weight: Berat ikan dalam gram
#Length1: Panjang vertikal dalam cm
#Length2: Panjang diagonal dalam cm
#Length3: Panjang silang dalam cm
#Height: Tinggi dalam cm
#Width: Lebar diagonal dalam cm

df.info()

print(str('Is there any NaN value in the dataset: '), df.isnull().values.any())
#mencari nilai null yang hilang

sp = df['Species'].value_counts()
sp = pd.DataFrame(sp)
sp.T
#jumlah setiap spesies

sns.barplot(x=sp.index, y=sp['Species']);
plt.xlabel('Species')
plt.ylabel('Counts of Species')
plt.show()
#rubah menjadi diagram bar

df.corr()
#korelasikan variabel

sns.heatmap(df.corr(), annot=True, cmap='YlGnBu');
#rubah menjadi heatmap

g = sns.pairplot(df, kind='scatter', hue='Species');
#perubahan bentuk grafik

df.describe().T
#statistik dataset

sns.boxplot(x=df['Weight']);
#boxplot yang menunjukkan distribusi data dari kolom 'Weight'

dfw = df['Weight']
dfw_Q1 = dfw.quantile(0.25)
dfw_Q3 = dfw.quantile(0.75)
dfw_IQR = dfw_Q3 - dfw_Q1
dfw_lowerend = dfw_Q1 - (1.5 * dfw_IQR)
dfw_upperend = dfw_Q3 + (1.5 * dfw_IQR)
#mengidentifikasi potensi outlier pada kolom 'Weight' dari DataFrame

dfw_outliers = dfw[(dfw < dfw_lowerend) | (dfw > dfw_upperend)]
dfw_outliers
#outlier

sns.boxplot(x=df['LengthVer']);
#boxplot yang menunjukkan distribusi data dari kolom 'LengthVer'

dflv = df['LengthVer']
dflv_Q1 = dflv.quantile(0.25)
dflv_Q3 = dflv.quantile(0.75)
dflv_IQR = dflv_Q3 - dflv_Q1
dflv_lowerend = dflv_Q1 - (1.5 * dflv_IQR)
dflv_upperend = dflv_Q3 + (1.5 * dflv_IQR)

dflv_outliers = dflv[(dflv < dflv_lowerend) | (dflv > dflv_upperend)]
dflv_outliers
#mengidentifikasi potensi outlier pada kolom 'LegnthVer' dari DataFrame

sns.boxplot(x=df['LengthDia']);

dfdia = df['LengthDia']
dfdia_Q1 = dfdia.quantile(0.25)
dfdia_Q3 = dfdia.quantile(0.75)
dfdia_IQR = dfdia_Q3 - dfdia_Q1
dfdia_lowerend = dfdia_Q1 - (1.5 * dfdia_IQR)
dfdia_upperend = dfdia_Q3 + (1.5 * dfdia_IQR)

dfdia_outliers = dfdia[(dfdia < dfdia_lowerend) | (dfdia > dfdia_upperend)]
dfdia_outliers

sns.boxplot(x=df['LengthCro']);

dfcro = df['LengthCro']
dfcro_Q1 = dfcro.quantile(0.25)
dfcro_Q3 = dfcro.quantile(0.75)
dfcro_IQR = dfcro_Q3 - dfcro_Q1
dfcro_lowerend = dfcro_Q1 - (1.5 * dfcro_IQR)
dfcro_upperend = dfcro_Q3 + (1.5 * dfcro_IQR)

dfcro_outliers = dfcro[(dfcro < dfcro_lowerend) | (dfcro > dfcro_upperend)]
dfcro_outliers

df[142:145]
#data outlier

df1 = df.drop([142,143,144])
df1.describe().T
#hapus data outlier dan analisis ulang dikarenakan data membuat data lain null

# Dependant (Target) Variable:
y = df1['Weight']
# Independant Variables:
X = df1.iloc[:,2:7]
#memisahkan variabel

from sklearn.model_selection import train_test_split
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=1)
#membagi dataset

print('X_train: ', np.shape(X_train))
print('y_train: ', np.shape(y_train))
print('X_test: ', np.shape(X_test))
print('y_test: ', np.shape(y_test))

reg = LinearRegression()
reg.fit(X_train,y_train)
#train mode'

print('Model intercept: ', reg.intercept_)
print('Model coefficients: ', reg.coef_)
#parameter model

print(f'y = {reg.intercept_:.2f} + {reg.coef_[0]:.2f}*X1 + {reg.coef_[1]:.2f}*X2 + {reg.coef_[2]:.2f}*X3 + {reg.coef_[3]:.2f}*X4 + {reg.coef_[4]:.2f}*X5')

y_head = reg.predict(X_train)

r2_score(y_train, y_head)

y_pred = reg.predict(X_test)
#Menggunakan Trained Model dan Test Dataset untuk Memperkirakan Bobot:

print(r2_score(y_test, y_pred))
#Menganalisis Keberhasilan Trained Model dari Test Dataset dan Prediksi:

plt.scatter(X_test['LengthVer'], y_test, color='purple', alpha=0.5)
plt.scatter(X_test['LengthVer'], y_pred, color='orange', alpha=0.5)
plt.xlabel('Vertical Length in cm')
plt.ylabel('Weight of the fish')
plt.title('Linear Regression Model for Weight Estimation');
#Visualisasi prediksi dengan LenghtVer

plt.scatter(X_test['LengthDia'], y_test, color='purple', alpha=0.4)
plt.scatter(X_test['LengthDia'], y_pred, color='green', alpha=0.4)
plt.xlabel('Diagonal Length in cm')
plt.ylabel('Weight of the fish')
plt.title('Linear Regression Model for Weight Estimation');

plt.scatter(X_test['Height'], y_test, color='orange', alpha=0.5)
plt.scatter(X_test['Height'], y_pred, color='blue', alpha=0.5)
plt.xlabel('Height in cm')
plt.ylabel('Weight of the fish')
plt.title('Linear Regression Model for Weight Estimation');

plt.scatter(X_test['Width'], y_test, color='gray', alpha=0.5)
plt.scatter(X_test['Width'], y_pred, color='red', alpha=0.5)
plt.xlabel('Width in cm')
plt.ylabel('Weight of the fish')
plt.title('Linear Regression Model for Weight Estimation');

y_pred1 = pd.DataFrame(y_pred, columns=['Estimasi Berat'])
y_pred1.head()
#estimasi berat

y_test1 = pd.DataFrame(y_test)
y_test1 = y_test1.reset_index(drop=True)
y_test1.head()

ynew = pd.concat([y_test1, y_pred1], axis=1)
ynew
#perbandingan data estimasi berat ikan menggunakan regresi linear

from sklearn.linear_model import LinearRegression
from sklearn.model_selection import train_test_split
import pickle

# Inisialisasi model regresi linear
model = LinearRegression()

# Latih model menggunakan data pelatihan
model.fit(X_train, y_train)

# Simpan model ke dalam file menggunakan pickle
with open('modelok.pkl', 'wb') as model_file:
    pickle.dump(model, model_file)